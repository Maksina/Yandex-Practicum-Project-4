### <a name="_b7urdng99y53"></a>**Название задачи:** Шардирование, репликация, миграция
### <a name="_hjk0fkfyohdk"></a>**Автор:** Щуренков Максим
### <a name="_uanumrh8zrui"></a>**Дата:** 09.11.2025

### <a name="_b7urdng99y54"></a>Проектирование схем коллекций для шардирования данных
## <a name="_3bfxc9a45514"></a>**Коллекция orders**

**Схема коллекции orders**

```json
{
  "_id": "ObjectId",
  "user_id": "ObjectId",
  "order_date": "ISODate",
  "items": [
    {
      "product_id": "ObjectId",
      "category": "string",
      "price": "number", 
    }
  ],
  "status": "string",
  "total_price": "number", 
  "geo_zone": "string" 
}
```

**Основные операции**
* Быстрое создание заказов с одновременным списанием остатков.
* Поиск истории заказов конкретного пользователя.
* Отображение статуса заказа.

**Решение**

* Шард-ключ: `{ "user_id": "hashed" }`
* Стратегия шардирования: Hash-Based
* Обоснование: 
    1) Равномерное распределение по шардам
    2) Создание заказа, поиск истории конкретного пользователя, отображение статуса заказа - задействуют всегда один и тот же шард.

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.orders.createIndex({ "user_id": "hashed" })
sh.shardCollection("somedb.orders", { "user_id": "hashed" })
```

**Альтернатива**

* Шард-ключ: `{ "user_id": "1" }`
* Стратегия шардирования: Range-Based
* Преимущества: Простота поддержки (Администратору проще понимать заказы каких пользователей находятся на каких шардах)
* Недостатки: Неравномерность распределения, учёт user_id, которые ниразу не делали заказы

**Недостатки, ограничения, риски**

Не учитываются пользователи, которые всегда совершают крупные заказы. Например, оптовый покупатель, заказы которого, могут так же находиться в данной базе.


## <a name="_3bfxc9a45514"></a>**Коллекция products**

**Схема коллекции products**

```json
{
  "_id": "ObjectId",
  "name": "string",
  "category": "string",
  "price": "number", 
  "stock": [
    {
      "zone": "string",
      "quantity": "int"
    }
  ],
  "attributes": [
    {
      "key": "string",
      "value": "string"
    }
  ]
}
```

**Основные операции**

* Частые обновления остатков при покупках.
* Поиск товаров по категориям и фильтрация по диапазону цен.
* Описание товара на странице продукта.

**Решение**

* Шард-ключ: `{ category: 1, _id: 1 }`
* Стратегия шардирования: Range-Based
* Обоснование: Покрывает все основные операции, локализуя их на конкретный шард. Выбор в пользу поиска, принимая во внимание, что распределение может быть не равномерным.

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.products.createIndex({ category: 1, _id: 1 })
sh.shardCollection("somedb.products", { category: 1, _id: 1 })
```

**Альтернатива**

* Шард-ключ: `{ "category": "hashed" }`
* Стратегия шардирования: Hash-Based
* Преимущества: Поиск товаров по категориям и фильтрация по цене локализованы на одном шарде
* Недостатки: Неравномерность распределения, частые обновления остатков и получения описания - задействуют разные шарды.

**Недостатки, ограничения, риски**

Выбранное решение вызывает неравномерность распределения, дополнительные ограничения на поиск и расширение схемы Orders на поле "category".

**Комментарий**

Данный выбор сделан с предположением, что поиск товаров по категориям и фильтрация по цене занимает значительный объем нагрузки.
Если при анализе нагрузки выяснится, что поиск по категориям вызывает незначительную нагрузку по сравнению с обновлением остатков и получением описания, то можно перейти на более простое решение в виде `{ _id: "hashed" }`

## <a name="_3bfxc9a45514"></a>**Коллекция carts**

**Схема коллекции carts**

```json
{
  "_id": "ObjectId",                
  "user_id": "ObjectId",        
  "session_id": "string",        
  "status": "string",
  "items": [
    {
      "product_id": "ObjectId",
      "category": "string",
      "quantity": "int"
    }
  ],
  "created_at": "ISODate",
  "updated_at": "ISODate",
  "expires_at": "ISODate" 
}
```

**Основные операции**

* Создание корзины, когда заходит гость или новый пользователь.
* Получение текущей корзины по фильтру { session_id, status:"active" } или { user_id, status:"active" }.
* Добавление или замена товара в корзине.
* Удаление товара из корзины.
* Слияние гостевой корзины в пользовательскую, если пользователь залогинится:
  * прочитать гостевую { session_id, status:"active" };
  * добавить её items в корзину { user_id, status:"active" };
  * отметить гостевую как abandoned.
* Отметка корзины как заказанной.

**Решение**

* Шард-ключ: `{ _id: "hashed" }`
* Стратегия шардирования: Hash-Based
* Обоснование: Большинство основных операций происходит с самой корзиной, что обуславливает выбор данного шард-ключа. Также, в таком случае распределение равномерно, действия с корзиной происходит в рамках одного шарда, смена владельца корзины не влияет на шардирование 

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.carts.createIndex({ _id: "hashed" })
sh.shardCollection("somedb.carts", { _id: "hashed" })
```

**Альтернатива**

* Шард-ключ: `{ user_id: "hashed" }`
* Стратегия шардирования: Hash-Based
* Преимущества: Равномерное распределение по шардам для авторизованных пользователей, операции по получению коризны пользователя попадают на один шард.
* Недостатки: Все гостевые корзины попадут в один шард, т.к. в таких случаях user_id = null


**Недостатки, ограничения, риски**

Поиск корзины по пользователю может задействовать несколько шардов, для минимизации таких действий необходимо предусмотреть кэширование, а для ускорения - индексы.

### <a name="_b7urdng99y55"></a>Выявление и устранение «горячих» шардов

## <a name="_3bfxc9a45514"></a>**Метрики**

|**№**|**Метрика**|**Команды MongoDB для получения данных**|**Стратегия мониторинга**|
| :-: | :- | :- | :- |
|1|Распределение чанков|```db.chunks.aggregate([{ $match: { ns: "somedb.products" } },{ $group: { _id: "$shard", chunkCount: { $sum: 1 } } },{ $sort: { chunkCount: -1 } }])```|Анализ количества чанков на каждом шарде. Если количество чанков значительно превышает (например x2) пороговое значение(например, среднее значение на остальных шардах) - Алерт|
|2|Размер шарда|```db.products.stats()```|Анализ значений size и count. Если полученные значения значительно(на 50+%) превышают пороговое значение(например, среднее значение на остальных шардах) - Алерт|
|3|Нагрузка на шард в реальном времени|```db.currentOp({"secs_running": { "$gt": 1 },"ns": "somedb.products"})```|Анализ нагрузки. Если полученные значения значительно(на 50+%) превышают пороговое значение(например, среднее значение на остальных шардах) - Алерт|
|4|Активные соединения по шардам|```db.serverStatus().metrics```|Анализ значений connections.current. Если полученные значения значительно(на 50+%) превышают пороговое значение(например, среднее значение на остальных шардах) - Алерт|
|5|CPU Utilization||Анализ загрузки CPU на шарде. При длительной(10+ минут) загрузке выше 85% - алерт|
|6|Query Latency||Анализ задержек на чтение и запись. Если полученные значения превышают пороговое значение(например, 200 мс) - Алерт|
|7|Bytes In/Out||Анализ трафика. Если полученные значения значительно(на 50+%) превышают пороговое значение(например, среднее значение на остальных шардах) - Алерт|

**Технологии для мониторинга:**  
* Prometeus
* Grafana

**Оповещение:**  
* Алертинг на почту ответственной команды


## <a name="_3bfxc9a45516"></a>**Автоматическое перераспределение данных**

1. **Включение и настройка балансировщика**

*Описание*: Балансировщик MongoDB автоматически перемещает чанки при дисбалансе.

*Включение балансировщика:*
```console
sh.setBalancerState(true)
```

*Проверка, что балансировщик включен:*
```console
sh.getBalancerState()
```

2. **Автоматическое дробление чанков**

*Описание*: Автоматическое дробление чанка при достижении им определенного размера.

*Включение функции auto-spit:*
```console
sh.enableAutoSplit()
```

*Проверка, что auto-spit включен:*
```console
sh.isAutoSplitEnabled()
```

3. **Настройка зон для автоматического распределения чанков**

*Описание*: Автоматическое распределение чанков на выбранную группу шардов.

*Добавление шардов в группу*:
```console
sh.addShardToZone("shard1-1", "high_category")
sh.addShardToZone("shard1-2", "high_category")
```

*Привязка шард-ключа к зоне*:
```console
sh.updateZoneKeyRange(
  "somedb.products",
  { "_id": { $minKey: X } },
  { "_id": { $maxKey: Y } },
  "high_capacity"
)
```

*Примечание*: Данный способ работает только с range-based ключами.

### <a name="_b7urdng99y56"></a>Настройка чтения с реплик и консистентность

|**Коллекция**|**Операции чтения**|**Primary**|**Secondary**|**Допустимая задержка репликации, сек**|**Обоснование**|
| :- | :- | :- | :- | :- | :- |
|orders|Поиск истории заказов конкретного пользователя|-|+|10|История заказов - результат завершенного процесса, поэтому данных в них не должны изменяться. Из-за этого допустима задержка и не моментальная актуальность.|
|orders|Чтение статуса заказа (все кроме "оплачено")|-|+|5|Для отображения статуса пользователю допустима задержка, т.к. нет высоких требований к консистентности, а данные обновляются редко.|
|orders|Чтение статуса заказа ("оплачено")|+|-|0|Единственный статус, который необходимо читать без задержки и обеспечивать высокую консистентность. Не актуальный статус может привети к повторной оплате и негативному пользовательскому опыту|
|products|Чтение остатков по товару|+|-|0| Из-за задержки в репликации можно продать товар, которого уже в остатках, что критично для текущего бизнес-процесса и консистентности данных |
|products|Поиск товаров по категориям и фильтрация по диапазону цен|-|+|5|Категории и цены товаров меняются достаточно редко, а поиск - самая частая операция в нашем процессе.|
|products|Описание товара на странице продукта|-|+|5|Описание товара меняется достаточно редко, консистентность не критична.|
|products|Чтение цены товара|+|-|0|Во избежании ошибок и потенциальных убытков из-за ошибочных цен или недополучения прибыли по акционным товарам, а также для позитивного пользовательского опыта - цену необходимо держать всегда в актуальном состоянии, но только на этапе оформления заказа|
|carts|Получение текущей корзины (пользовательской и гостевой)|+|-|0|Частые изменения в корзине, слияние корзин и т.д. требуют консистентных данных для позитивного пользовательского опыта и избегания ошибок при добавлении/удалении товаров|


*Примечание*: 5 и 10 секунд выбраны исходя из собственного опыта и иследований. Считаем, что 5 секунд - максимальное задержка, когда пользователь не замечает расхождения отображаемых данных с фактическими, а для системы такая консистентность допустима. 10 секунд - заметная задержка для пользователя, но актуальность данных не критична, что также не должно вызывать негативный опыт.

### <a name="_b7urdng99y57"></a>Миграция на Cassandra: модель данных, стратегии репликации и шардирования

## <a name="_3bfxc9a45514"></a>**Применимость Cassandra**

|**Данные**|**Критичность**|**Применимость Cassandra**|**Обоснование**|
| :- | :- | :- | :- |
|Заказы|Высокая|Нет|Требуется транзакционная логика.|
|Товары|Высокая|Нет|Требуется строгая консистентность данных по остаткам|
|Корзины|Средняя|Да|Высокая скорость обработки записи в БД, встроенный TTL, горизонтальное масштабирование без полного перераспределения|
|История заказов|Низкая|Да|Высокая доступность чтения, только добавление данных без последующих изменений, удобное патиционировение|
|Пользовательские сессии|Низкая|Да|Высокая скорость обработки записи в БД, встроенный TTL, возможность реализации геораспределенности|

## <a name="_3bfxc9a45515"></a>**Модели данных**

1. **Корзины (Carts)**

Для обеспечения равномерного распределения, гибкости и масштабирования разделим данные корзин на 2 части: корзины авторизованных пользователей (user_carts) и корзины неавторизованных пользователей (guest_carts).

**Корзины авторизованных пользователей**

```sql
CREATE TABLE user_carts (
    user_id    UUID,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    expires_at TIMESTAMP,
    status     TEXT,
    items      LIST<FROZEN<{
        product_id UUID,
        category   TEXT,
        quantity   INT
    }>>,
    PRIMARY KEY (user_id)
)
```

- *Partition key*: `user_id`
- *TTL*: Нет автоматического удаления корзин у авторизованных пользователей для повышения UX.
- *Распределение нагрузки*: У каждого пользователя своя партиция -> нагрузка равномерно распределена. При экстремальной нагрузки можно легко масштабировать не вызывая полного перераспределения.

**Корзины неавторизованных пользователей**

```sql
CREATE TABLE guest_carts (
    session_id TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    expires_at TIMESTAMP,
    status     TEXT,
    items      LIST<FROZEN<{
        product_id UUID,
        category   TEXT,
        quantity   INT
    }>>,
    PRIMARY KEY (session_id)
) WITH default_time_to_live = 604800;
```

- *Partition key*: `session_id`
- *TTL*: Автоматическое удаление гостевых корзин через 7 дней. Важно учитывать TTL для самой сессии, т.к. хранить корзину дольше, чем жива сессии - не имеет смысла.
- *Распределение нагрузки*: У каждой сессии своя партиция -> нагрузка равномерно распределена. При экстремальной нагрузки можно легко масштабировать не вызывая полного перераспределения.


2. **История заказов (order_history)**

```sql
CREATE TABLE order_history (
    user_id      UUID,
    order_date   TIMESTAMP,
    order_id     UUID,
    status       TEXT,
    total_price  DECIMAL,
    geo_zone     TEXT,
    items        LIST<FROZEN<{
        product_id UUID,
        category   TEXT,
        price      DECIMAL
    }>>,
    PRIMARY KEY (user_id, order_date)
) WITH CLUSTERING ORDER BY (order_date DESC);
```

- *Partition key*: `user_id`
- *Clustering key*: `order_date`
- *TTL*: Нет автоматического удаления заказов для аналитики и повышения UX.
- *Распределение нагрузки*: У каждого пользователя своя партиция, заказы внутри партизации отсортированные по дате -> нагрузка равномерно распределена.

3. **Пользовательские сессии**

```sql
CREATE TABLE user_sessions (
    session_id   TEXT,        
    user_id      UUID,        
    created_at   TIMESTAMP,
    last_active  TIMESTAMP,
    ip_address   INET,
    user_agent   TEXT,
    status       TEXT,    
    PRIMARY KEY (session_id)
) WITH default_time_to_live = 604800;
```

- *Partition key*: `session_id`
- *TTL*: Автоматическая очистка сессии через 7 дней.
- *Распределение нагрузки*: У каждой сессии своя партиция -> нагрузка равномерно распределена. При экстремальной нагрузки можно легко масштабировать не вызывая полного перераспределения.

## <a name="_3bfxc9a45515"></a>**Целостность данных**

|**Данные**|**Hinted Handoff**|**Read Repair**|**Anti-Entropy Repair**|**Обоснование**|
| :- | :- | :- | :- | :- |
|Корзины|Да|Да(QUORUM)|Да(По рассписанию)|Требуется высокая доступность, но возможна временна неконсистентность|
|История заказов|Да|Да(QUORUM)|Да(По рассписанию)|Редкое обновление, высокие требования к консистентности и целостности|
|Пользовательские сессии|Да|Да(ONE)|Нет|Максимальная скорость и доступность, низкие требования к целостности|
