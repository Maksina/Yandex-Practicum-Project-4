### <a name="_b7urdng99y53"></a>**Название задачи:** Проектирование схем коллекций для шардирования данных
### <a name="_hjk0fkfyohdk"></a>**Автор:** Щуренков Максим
### <a name="_uanumrh8zrui"></a>**Дата:** 09.11.2025

### <a name="_3bfxc9a45514"></a>**Коллекция orders**

**Схема коллекции orders**

```json
{
  "_id": "ObjectId",
  "user_id": "ObjectId",
  "order_date": "ISODate",
  "items": [
    {
      "product_id": "ObjectId",
      "category": "string",
      "price": "number", 
    }
  ],
  "status": "string",
  "total_price": "number", 
  "geo_zone": "string" 
}
```

**Основные операции**
* Быстрое создание заказов с одновременным списанием остатков.
* Поиск истории заказов конкретного пользователя.
* Отображение статуса заказа.

**Решение**

* Шард-ключ: `{ "user_id": "hashed" }`
* Стратегия шардирования: Hash-Based
* Обоснование: 
    1) Равномерное распределение по шардам
    2) Создание заказа, поиск истории конкретного пользователя, отображение статуса заказа - задействуют всегда один и тот же шард.

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.orders.createIndex({ "user_id": "hashed" })
sh.shardCollection("somedb.orders", { "user_id": "hashed" })
```

**Альтернатива**

* Шард-ключ: `{ "user_id": "1" }`
* Стратегия шардирования: Range-Based
* Преимущества: Простота поддержки (Администратору проще понимать заказы каких пользователей находятся на каких шардах)
* Недостатки: Неравномерность распределения, учёт user_id, которые ниразу не делали заказы

**Недостатки, ограничения, риски**

Не учитываются пользователи, которые всегда совершают крупные заказы. Например, оптовый покупатель, заказы которого, могут так же находиться в данной базе.


### <a name="_3bfxc9a45514"></a>**Коллекция products**

**Схема коллекции products**

```json
{
  "_id": "ObjectId",
  "name": "string",
  "category": "string",
  "price": "number", 
  "stock": [
    {
      "zone": "string",
      "quantity": "int"
    }
  ],
  "attributes": [
    {
      "key": "string",
      "value": "string"
    }
  ]
}
```

**Основные операции**

* Частые обновления остатков при покупках.
* Поиск товаров по категориям и фильтрация по диапазону цен.
* Описание товара на странице продукта.

**Решение**

* Шард-ключ: `{ category: 1, _id: 1 }`
* Стратегия шардирования: Range-Based
* Обоснование: Покрывает все основные операции, локализуя их на конкретный шард. Выбор в пользу поиска, принимая во внимание, что распределение может быть не равномерным.

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.products.createIndex({ category: 1, _id: 1 })
sh.shardCollection("somedb.products", { category: 1, _id: 1 })
```

**Альтернатива**

* Шард-ключ: `{ "category": "hashed" }`
* Стратегия шардирования: Hash-Based
* Преимущества: Поиск товаров по категориям и фильтрация по цене локализованы на одном шарде
* Недостатки: Неравномерность распределения, частые обновления остатков и получения описания - задействуют разные шарды.

**Недостатки, ограничения, риски**
Выбранное решение вызывает неравномерность распределения, дополнительные ограничения на поиск и расширение схемы Orders на поле "category".

**Комментарий**
Данный выбор сделан с предположением, что поиск товаров по категориям и фильтрация по цене занимает значительный объем нагрузки.
Если при анализе нагрузки выяснится, что поиск по категориям вызывает незначительную нагрузку по сравнению с обновлением остатков и получением описания, то можно перейти на более простое решение в виде `{ _id: "hashed" }`

### <a name="_3bfxc9a45514"></a>**Коллекция carts**

**Схема коллекции carts**

```json
{
  "_id": "ObjectId",                
  "user_id": "ObjectId",        
  "session_id": "string",        
  "status": "string",
  "items": [
    {
      "product_id": "ObjectId",
      "category": "string",
      "quantity": "int"
    }
  ],
  "created_at": "ISODate",
  "updated_at": "ISODate",
  "expires_at": "ISODate" 
}
```

**Основные операции**

* Создание корзины, когда заходит гость или новый пользователь.
* Получение текущей корзины по фильтру { session_id, status:"active" } или { user_id, status:"active" }.
* Добавление или замена товара в корзине.
* Удаление товара из корзины.
* Слияние гостевой корзины в пользовательскую, если пользователь залогинится:
  * прочитать гостевую { session_id, status:"active" };
  * добавить её items в корзину { user_id, status:"active" };
  * отметить гостевую как abandoned.
* Отметка корзины как заказанной.

**Решение**

* Шард-ключ: `{ _id: "hashed" }`
* Стратегия шардирования: Hash-Based
* Обоснование: Большинство основных операций происходит с самой корзиной, что обуславливает выбор данного шард-ключа. Также, в таком случае распределение равномерно, действия с корзиной происходит в рамках одного шарда, смена владельца корзины не влияет на шардирование 

**Команды MongoDB**

```console
sh.enableSharding("somedb")
db.carts.createIndex({ _id: "hashed" })
sh.shardCollection("somedb.carts", { _id: "hashed" })
```

**Альтернатива**

* Шард-ключ: `{ user_id: "hashed" }`
* Стратегия шардирования: Hash-Based
* Преимущества: Равномерное распределение по шардам для авторизованных пользователей, операции по получению коризны пользователя попадают на один шард.
* Недостатки: Все гостевые корзины попадут в один шард, т.к. в таких случаях user_id = null


**Недостатки, ограничения, риски**
Поиск корзины по пользователю может задействовать несколько шардов, для минимизации таких действий необходимо предусмотреть кэширование, а для ускорения - индексы.



